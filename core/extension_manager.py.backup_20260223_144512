"""
Gestor de extensiones telefónicas para VoIP Auto Dialer
Maneja la asignación automática de extensiones a agentes
"""
import json
import os
import random
import string
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

from core.logging_config import get_logger

class ExtensionManager:
    """Gestor de extensiones telefónicas"""
    
    def __init__(self, data_dir: str = "data"):
        self.logger = get_logger("extension_manager")
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        
        # Archivos de datos
        self.extensions_file = self.data_dir / "extensions.json"
        self.config_dir = self.data_dir / "softphone_configs"
        self.config_dir.mkdir(exist_ok=True)
        
        # Configuración de extensiones
        self.extension_range = (1000, 1999)  # Rango de extensiones
        self.sip_server = "localhost"
        self.sip_port = 5060
        
        # Cargar extensiones existentes
        self.extensions = self._load_extensions()
        
        self.logger.info(f"Extension Manager inicializado: {len(self.extensions)} extensiones")
    
    def _load_extensions(self) -> Dict[str, Dict[str, Any]]:
        """Cargar extensiones desde archivo"""
        if self.extensions_file.exists():
            try:
                with open(self.extensions_file, 'r') as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                self.logger.warning("Error cargando extensions.json, creando nuevo")
        
        return {}
    
    def _save_extensions(self):
        """Guardar extensiones a archivo"""
        try:
            with open(self.extensions_file, 'w') as f:
                json.dump(self.extensions, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error guardando extensions.json: {e}")
    
    def _generate_password(self, length: int = 12) -> str:
        """Generar contraseña aleatoria para extensión"""
        chars = string.ascii_letters + string.digits + "!@#$%^&*"
        return ''.join(random.choice(chars) for _ in range(length))
    
    def _find_next_available_extension(self) -> Optional[int]:
        """Encontrar la siguiente extensión disponible"""
        start, end = self.extension_range
        
        for ext_num in range(start, end + 1):
            ext_str = str(ext_num)
            if ext_str not in self.extensions or self.extensions[ext_str].get('status') == 'available':
                return ext_num
        
        return None
    
    def create_extension_pool(self, count: int = 500) -> int:
        """Crear un pool de extensiones disponibles"""
        created = 0
        start, end = self.extension_range
        
        for i in range(count):
            ext_num = start + i
            if ext_num > end:
                break
                
            ext_str = str(ext_num)
            if ext_str not in self.extensions:
                self.extensions[ext_str] = {
                    'extension': ext_str,
                    'password': self._generate_password(),
                    'status': 'available',
                    'assigned_to': None,
                    'assigned_at': None,
                    'created_at': datetime.now().isoformat()
                }
                created += 1
        
        if created > 0:
            self._save_extensions()
            self.logger.info(f"Creadas {created} nuevas extensiones")
        
        return created
    
    def assign_extension(self, agent_id: str, agent_name: str = None) -> Optional[Dict[str, Any]]:
        """Asignar extensión automáticamente a un agente"""
        try:
            # Buscar extensión disponible
            ext_num = self._find_next_available_extension()
            if not ext_num:
                self.logger.error("No hay extensiones disponibles")
                return None
            
            ext_str = str(ext_num)
            
            # Si la extensión no existe, crearla
            if ext_str not in self.extensions:
                self.extensions[ext_str] = {
                    'extension': ext_str,
                    'password': self._generate_password(),
                    'status': 'available',
                    'assigned_to': None,
                    'assigned_at': None,
                    'created_at': datetime.now().isoformat()
                }
            
            # Asignar extensión
            self.extensions[ext_str].update({
                'status': 'assigned',
                'assigned_to': agent_id,
                'assigned_at': datetime.now().isoformat(),
                'agent_name': agent_name or agent_id
            })
            
            self._save_extensions()
            
            result = {
                'extension': ext_str,
                'password': self.extensions[ext_str]['password'],
                'status': 'assigned',
                'assigned_at': self.extensions[ext_str]['assigned_at']
            }
            
            self.logger.info(f"Extensión {ext_str} asignada a {agent_id}")
            return result
            
        except Exception as e:
            self.logger.error(f"Error asignando extensión: {e}")
            return None
    
    def release_extension(self, agent_id: str) -> bool:
        """Liberar extensión de un agente"""
        try:
            for ext_str, ext_data in self.extensions.items():
                if ext_data.get('assigned_to') == agent_id:
                    ext_data.update({
                        'status': 'available',
                        'assigned_to': None,
                        'assigned_at': None,
                        'agent_name': None,
                        'released_at': datetime.now().isoformat()
                    })
                    
                    self._save_extensions()
                    self.logger.info(f"Extensión {ext_str} liberada de {agent_id}")
                    return True
            
            self.logger.warning(f"No se encontró extensión asignada a {agent_id}")
            return False
            
        except Exception as e:
            self.logger.error(f"Error liberando extensión: {e}")
            return False
    
    def get_agent_extension(self, agent_id: str) -> Optional[Dict[str, Any]]:
        """Obtener información de extensión de un agente"""
        for ext_str, ext_data in self.extensions.items():
            if ext_data.get('assigned_to') == agent_id:
                return {
                    'extension': ext_str,
                    'password': ext_data['password'],
                    'status': ext_data['status'],
                    'assigned_at': ext_data.get('assigned_at')
                }
        return None
    
    def get_stats(self) -> Dict[str, Any]:
        """Obtener estadísticas de extensiones"""
        total = len(self.extensions)
        assigned = sum(1 for ext in self.extensions.values() if ext.get('status') == 'assigned')
        available = total - assigned
        
        return {
            'total_extensions': total,
            'assigned_extensions': assigned,
            'available_extensions': available,
            'utilization_rate': (assigned / total * 100) if total > 0 else 0.0
        }
    
    def generate_softphone_config(self, agent_id: str, config_type: str = 'generic') -> Optional[str]:
        """Generar archivo de configuración para softphone"""
        ext_info = self.get_agent_extension(agent_id)
        if not ext_info:
            return None
        
        extension = ext_info['extension']
        password = ext_info['password']
        
        # Obtener nombre del agente (si está disponible)
        agent_name = "Usuario"
        for ext_data in self.extensions.values():
            if ext_data.get('assigned_to') == agent_id:
                agent_name = ext_data.get('agent_name', agent_id)
                break
        
        config_content = ""
        file_extension = "txt"
        
        if config_type == 'zoiper':
            config_content = f"""[{extension}]
username={extension}
password={password}
domain={self.sip_server}
proxy={self.sip_server}:{self.sip_port}
transport=UDP
display_name={agent_name}
enabled=1
register=1
"""
            file_extension = "conf"
            
        elif config_type == 'portsip':
            config_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<PortSIP>
    <Account>
        <DisplayName>{agent_name}</DisplayName>
        <UserName>{extension}</UserName>
        <Password>{password}</Password>
        <SIPServer>{self.sip_server}</SIPServer>
        <SIPServerPort>{self.sip_port}</SIPServerPort>
        <Transport>UDP</Transport>
        <Enabled>true</Enabled>
    </Account>
</PortSIP>"""
            file_extension = "xml"
            
        else:  # generic
            config_content = f"""=== CONFIGURACIÓN SIP ===
Extensión: {extension}
Contraseña: {password}
Servidor SIP: {self.sip_server}
Puerto: {self.sip_port}
Transporte: UDP
Nombre: {agent_name}

=== INSTRUCCIONES ===
1. Instala tu aplicación SIP favorita (Zoiper, PortSIP, etc.)
2. Crea una nueva cuenta SIP
3. Usa los datos de arriba para configurar la cuenta
4. Guarda y registra la cuenta

=== SOPORTE ===
Si tienes problemas, contacta al administrador del sistema.
"""
        
        # Guardar archivo de configuración
        config_filename = f"{config_type}_config_{extension}.{file_extension}"
        config_path = self.config_dir / config_filename
        
        try:
            with open(config_path, 'w') as f:
                f.write(config_content)
            
            self.logger.info(f"Configuración {config_type} generada para extensión {extension}")
            return str(config_path)
            
        except Exception as e:
            self.logger.error(f"Error generando configuración: {e}")
            return None
    
    def get_softphone_config(self, agent_id: str, config_type: str) -> Optional[str]:
        """Obtener ruta del archivo de configuración de softphone"""
        ext_info = self.get_agent_extension(agent_id)
        if not ext_info:
            return None
        
        extension = ext_info['extension']
        file_extensions = {
            'zoiper': 'conf',
            'portsip': 'xml',
            'generic': 'txt'
        }
        
        file_ext = file_extensions.get(config_type, 'txt')
        config_filename = f"{config_type}_config_{extension}.{file_ext}"
        config_path = self.config_dir / config_filename
        
        # Si no existe, generarlo
        if not config_path.exists():
            return self.generate_softphone_config(agent_id, config_type)
        
        return str(config_path)

# Instancia global del gestor de extensiones
extension_manager = ExtensionManager()

# Crear pool inicial de extensiones si no existen
if len(extension_manager.extensions) == 0:
    extension_manager.create_extension_pool(500)