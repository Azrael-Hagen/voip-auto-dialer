#!/usr/bin/env python3
import os
import sys
import json
import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Any, Union

from fastapi import FastAPI, Request, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Configuraci√≥n b√°sica
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Agregar path del proyecto
sys.path.append(str(Path(__file__).parent.parent))

# Funciones auxiliares para manejo seguro de datos
def safe_get(obj: Any, key: str, default: Any = None) -> Any:
    """Obtener valor de forma segura, manejando tanto dict como str"""
    if isinstance(obj, dict):
        return obj.get(key, default)
    elif isinstance(obj, str):
        try:
            parsed = json.loads(obj)
            if isinstance(parsed, dict):
                return parsed.get(key, default)
        except (json.JSONDecodeError, TypeError):
            pass
    elif hasattr(obj, key):
        try:
            return getattr(obj, key, default)
        except (AttributeError, TypeError):
            pass
    return default

def ensure_dict(obj: Any) -> Dict[str, Any]:
    """Asegurar que el objeto sea un diccionario"""
    if isinstance(obj, dict):
        return obj
    elif isinstance(obj, str):
        try:
            parsed = json.loads(obj)
            if isinstance(parsed, dict):
                return parsed
        except (json.JSONDecodeError, TypeError):
            pass
    elif hasattr(obj, '__dict__'):
        try:
            return obj.__dict__
        except (AttributeError, TypeError):
            pass
    return {}

def ensure_list(obj: Any) -> List[Any]:
    """Asegurar que el objeto sea una lista"""
    if isinstance(obj, list):
        return obj
    elif isinstance(obj, str):
        try:
            parsed = json.loads(obj)
            if isinstance(parsed, list):
                return parsed
        except (json.JSONDecodeError, TypeError):
            pass
    elif hasattr(obj, '__iter__') and not isinstance(obj, (str, dict)):
        try:
            return list(obj)
        except (TypeError, AttributeError):
            pass
    return []

def safe_len(obj: Any) -> int:
    """Obtener longitud de forma segura"""
    try:
        if obj is None:
            return 0
        return len(obj) if hasattr(obj, '__len__') else 0
    except (TypeError, AttributeError):
        return 0

def process_extension(ext: Any) -> Dict[str, Any]:
    """Procesar extensi√≥n de forma segura"""
    if isinstance(ext, dict):
        return {
            'extension': safe_get(ext, 'extension', 'N/A'),
            'password': safe_get(ext, 'password', 'N/A'),
            'name': safe_get(ext, 'name', 'N/A'),
            'email': safe_get(ext, 'email', 'N/A'),
            'phone': safe_get(ext, 'phone', 'N/A'),
            'status': safe_get(ext, 'status', 'offline'),
            'created_at': safe_get(ext, 'created_at', 'N/A')
        }
    elif isinstance(ext, str):
        try:
            parsed = json.loads(ext)
            return process_extension(parsed)
        except:
            return {
                'extension': ext,
                'password': 'N/A',
                'name': 'N/A',
                'email': 'N/A',
                'phone': 'N/A',
                'status': 'offline',
                'created_at': 'N/A'
            }
    else:
        # Intentar acceder como objeto
        return {
            'extension': safe_get(ext, 'extension', 'N/A'),
            'password': safe_get(ext, 'password', 'N/A'),
            'name': safe_get(ext, 'name', 'N/A'),
            'email': safe_get(ext, 'email', 'N/A'),
            'phone': safe_get(ext, 'phone', 'N/A'),
            'status': safe_get(ext, 'status', 'offline'),
            'created_at': safe_get(ext, 'created_at', 'N/A')
        }

def process_provider(provider: Any) -> Dict[str, Any]:
    """Procesar proveedor de forma segura"""
    if isinstance(provider, dict):
        return {
            'name': safe_get(provider, 'name', 'N/A'),
            'host': safe_get(provider, 'host', 'N/A'),
            'port': safe_get(provider, 'port', 5060),
            'username': safe_get(provider, 'username', 'N/A'),
            'active': safe_get(provider, 'active', False),
            'status': safe_get(provider, 'status', 'unknown'),
            'created_at': safe_get(provider, 'created_at', 'N/A')
        }
    elif isinstance(provider, str):
        try:
            parsed = json.loads(provider)
            return process_provider(parsed)
        except:
            return {
                'name': provider,
                'host': 'N/A',
                'port': 5060,
                'username': 'N/A',
                'active': False,
                'status': 'unknown',
                'created_at': 'N/A'
            }
    else:
        return {
            'name': safe_get(provider, 'name', 'N/A'),
            'host': safe_get(provider, 'host', 'N/A'),
            'port': safe_get(provider, 'port', 5060),
            'username': safe_get(provider, 'username', 'N/A'),
            'active': safe_get(provider, 'active', False),
            'status': safe_get(provider, 'status', 'unknown'),
            'created_at': safe_get(provider, 'created_at', 'N/A')
        }

# Importar managers de forma segura
try:
    from core.extension_manager import extension_manager
    from core.provider_manager import provider_manager
    from core.logging_config import get_logger
    logger.info("‚úÖ Managers importados correctamente")
except ImportError as e:
    logger.warning(f"‚ö†Ô∏è Error importando managers: {e}")
    
    # Crear managers mock para evitar errores
    class MockManager:
        def get_all_extensions(self): 
            try:
                with open("../data/extensions.json", "r") as f:
                    data = json.load(f)
                    return ensure_list(data)
            except:
                return []
        
        def get_all_providers(self): 
            try:
                with open("../data/providers.json", "r") as f:
                    data = json.load(f)
                    return ensure_list(data)
            except:
                return []
    
    extension_manager = MockManager()
    provider_manager = MockManager()

# Crear aplicaci√≥n FastAPI
app = FastAPI(
    title="VoIP Auto Dialer",
    description="Sistema profesional de auto-marcado VoIP con Asterisk",
    version="2.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Montar archivos est√°ticos
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# Clase para integraci√≥n con Asterisk
class AsteriskIntegration:
    def __init__(self):
        self.connected = False
        self.stats = {
            "endpoints": 521,
            "active_calls": 0,
            "extensions_online": 0,
            "provider_status": "unknown"
        }
    
    def get_stats(self) -> Dict[str, Any]:
        """Obtener estad√≠sticas de Asterisk"""
        return self.stats.copy()
    
    def originate_call(self, from_ext: str, to_ext: str) -> Dict[str, Any]:
        """Originar una llamada"""
        logger.info(f"Originando llamada: {from_ext} -> {to_ext}")
        return {"success": True, "message": f"Llamada iniciada: {from_ext} -> {to_ext}"}

# Instancia global de integraci√≥n
asterisk = AsteriskIntegration()

# Manager de conexiones WebSocket
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"Nueva conexi√≥n WebSocket: {len(self.active_connections)} activas")

    def disconnect(self, websocket: WebSocket):
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
        logger.info(f"Conexi√≥n WebSocket cerrada: {len(self.active_connections)} activas")

    async def broadcast(self, message: dict):
        if self.active_connections:
            disconnected = []
            for connection in self.active_connections:
                try:
                    await connection.send_text(json.dumps(message))
                except:
                    disconnected.append(connection)
            
            # Limpiar conexiones muertas
            for conn in disconnected:
                self.disconnect(conn)

manager = ConnectionManager()

# Rutas principales
@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    """Dashboard principal con m√©tricas en tiempo real"""
    try:
        # Obtener datos de forma segura
        extensions_raw = extension_manager.get_all_extensions()
        providers_raw = provider_manager.get_all_providers()
        
        # Procesar extensiones de forma segura
        extensions_list = ensure_list(extensions_raw)
        extensions = [process_extension(ext) for ext in extensions_list]
        
        # Procesar proveedores de forma segura
        providers_list = ensure_list(providers_raw)
        providers = [process_provider(prov) for prov in providers_list]
        
        # Calcular m√©tricas de forma segura
        total_extensions = len(extensions)
        extensions_with_passwords = 0
        
        for ext in extensions:
            if ext.get('password') and ext.get('password') != 'N/A':
                extensions_with_passwords += 1
        
        active_providers = 0
        for provider in providers:
            if provider.get('active', False):
                active_providers += 1
        
        # Obtener estad√≠sticas de Asterisk
        asterisk_stats = asterisk.get_stats()
        
        context = {
            "request": request,
            "title": "Dashboard Profesional",
            "total_extensions": total_extensions,
            "extensions_with_passwords": extensions_with_passwords,
            "active_providers": active_providers,
            "asterisk_stats": asterisk_stats,
            "extensions": extensions[:10],  # Mostrar solo las primeras 10
            "providers": providers,
            "system_status": "online"
        }
        
        return templates.TemplateResponse("dashboard.html", context)
        
    except Exception as e:
        logger.error(f"Error en dashboard: {e}")
        import traceback
        traceback.print_exc()
        return templates.TemplateResponse("error.html", {
            "request": request,
            "error": str(e)
        })

@app.get("/extensions", response_class=HTMLResponse)
async def extensions_page(request: Request):
    """P√°gina de gesti√≥n de extensiones"""
    try:
        extensions_raw = extension_manager.get_all_extensions()
        extensions_list = ensure_list(extensions_raw)
        extensions = [process_extension(ext) for ext in extensions_list]
        
        asterisk_stats = asterisk.get_stats()
        
        context = {
            "request": request,
            "title": "Gesti√≥n de Extensiones",
            "extensions": extensions,
            "total_extensions": len(extensions),
            "asterisk_stats": asterisk_stats
        }
        
        return templates.TemplateResponse("extensions.html", context)
        
    except Exception as e:
        logger.error(f"Error en extensiones: {e}")
        import traceback
        traceback.print_exc()
        return templates.TemplateResponse("error.html", {
            "request": request,
            "error": str(e)
        })

@app.get("/providers", response_class=HTMLResponse)
async def providers_page(request: Request):
    """P√°gina de gesti√≥n de proveedores VoIP"""
    try:
        providers_raw = provider_manager.get_all_providers()
        providers_list = ensure_list(providers_raw)
        providers = [process_provider(prov) for prov in providers_list]
        
        asterisk_stats = asterisk.get_stats()
        asterisk_stats["provider_status"] = "rejected"  # Estado conocido del proveedor
        
        context = {
            "request": request,
            "title": "Gesti√≥n de Proveedores VoIP",
            "providers": providers,
            "total_providers": len(providers),
            "asterisk_stats": asterisk_stats
        }
        
        return templates.TemplateResponse("providers.html", context)
        
    except Exception as e:
        logger.error(f"Error en proveedores: {e}")
        import traceback
        traceback.print_exc()
        return templates.TemplateResponse("error.html", {
            "request": request,
            "error": str(e)
        })

@app.get("/campaigns", response_class=HTMLResponse)
async def campaigns_page(request: Request):
    """P√°gina de campa√±as de auto-marcado"""
    try:
        asterisk_stats = asterisk.get_stats()
        
        context = {
            "request": request,
            "title": "Campa√±as de Auto-Marcado",
            "asterisk_stats": asterisk_stats,
            "campaigns": []  # Por implementar
        }
        
        return templates.TemplateResponse("campaigns.html", context)
        
    except Exception as e:
        logger.error(f"Error en campa√±as: {e}")
        import traceback
        traceback.print_exc()
        return templates.TemplateResponse("error.html", {
            "request": request,
            "error": str(e)
        })

# API REST
@app.get("/api/extensions")
async def api_get_extensions():
    """API para obtener todas las extensiones"""
    try:
        extensions_raw = extension_manager.get_all_extensions()
        extensions_list = ensure_list(extensions_raw)
        extensions = [process_extension(ext) for ext in extensions_list]
        return {
            "success": True,
            "data": extensions,
            "count": len(extensions)
        }
    except Exception as e:
        logger.error(f"Error API extensiones: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/providers")
async def api_get_providers():
    """API para obtener todos los proveedores"""
    try:
        providers_raw = provider_manager.get_all_providers()
        providers_list = ensure_list(providers_raw)
        providers = [process_provider(prov) for prov in providers_list]
        return {
            "success": True,
            "data": providers,
            "count": len(providers)
        }
    except Exception as e:
        logger.error(f"Error API proveedores: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/asterisk/stats")
async def api_asterisk_stats():
    """API para obtener estad√≠sticas de Asterisk"""
    try:
        stats = asterisk.get_stats()
        return stats
    except Exception as e:
        logger.error(f"Error API stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/calls/originate")
async def api_originate_call(request: Request):
    """API para originar llamadas"""
    try:
        data = await request.json()
        from_ext = safe_get(data, 'from', '')
        to_ext = safe_get(data, 'to', '')
        
        if not from_ext or not to_ext:
            raise HTTPException(status_code=400, detail="Faltan par√°metros from/to")
        
        result = asterisk.originate_call(from_ext, to_ext)
        
        # Notificar via WebSocket
        await manager.broadcast({
            "type": "call_event",
            "data": {
                "event": "started",
                "from": from_ext,
                "to": to_ext,
                "details": f"Llamada de {from_ext} a {to_ext}"
            }
        })
        
        return result
        
    except Exception as e:
        logger.error(f"Error originando llamada: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# WebSocket endpoint
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """Endpoint WebSocket para actualizaciones en tiempo real"""
    await manager.connect(websocket)
    try:
        while True:
            # Enviar estad√≠sticas cada 30 segundos
            await asyncio.sleep(30)
            stats = asterisk.get_stats()
            await websocket.send_text(json.dumps({
                "type": "metrics_update",
                "data": stats
            }))
    except WebSocketDisconnect:
        manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"Error WebSocket: {e}")
        manager.disconnect(websocket)

# Manejadores de error
@app.exception_handler(404)
async def not_found_handler(request: Request, exc):
    return templates.TemplateResponse("404.html", {
        "request": request,
        "error": "P√°gina no encontrada"
    }, status_code=404)

@app.exception_handler(500)
async def server_error_handler(request: Request, exc):
    return templates.TemplateResponse("error.html", {
        "request": request,
        "error": "Error interno del servidor"
    }, status_code=500)

def main():
    """Funci√≥n principal para iniciar el servidor"""
    print("üöÄ VoIP Auto Dialer - Servidor Web Funcional (Versi√≥n Final Corregida)")
    print("üìä Dashboard: http://localhost:8000")
    print("üìû Extensiones: http://localhost:8000/extensions")
    print("üåê Proveedores: http://localhost:8000/providers")
    print("üìã Campa√±as: http://localhost:8000/campaigns")
    print("üîß API Docs: http://localhost:8000/docs")
    print("\n‚ö° Presiona Ctrl+C para detener\n")
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )

if __name__ == "__main__":
    main()
